# EnginesExam
OBJECT POOLING EXPLAINATION
Object pooling was implemented by having a Queue of ducks that can be used at any one time. Whenever a duck is needed, a duck is popped from the Queue and the gameobeject of that duck is enabled so it can fly freely. There are 5 ducks in the scene. In their Start() methods, they add themselves to the Queue of ducks in the DuckManager. When they are added, their gameObject gets inactivated and their position is set to the DuckManager's position in world space. The DuckManager has code running in the Update() funciton that creates new ducks every 0.5 seconds. When a new duck needs to be created, the duck at the top of the Queue is popped and its gameObject is activated. In the Update() function of the ducks, their position is set to rise. Since the duck's gameObject has been enabled, the duck can sart to rise up until they hit the reset collider at the top of the scene. Once they hit the reset collider, they are added back into the Queue and deactivated again.


Object Pooling editor results are available in the Object Pooling folder as images. The use of object pooling helps reduce the games memory by about 10MB due to the controlled creation of GameObjects. The CPU use time is also down by about 10MS since there is no need to destroy and create gameobjects. When gameobjects can be reused, it saves computational power. This is important for allowing the game to run on weaker hardware and for allowing room for expanding the game without worrying about performance later down the line.

COMMAND DESIGN PATTERN EXPLAINATION
The command design pattern works by creating an abstract class called Command that has a DoAction() method. This function gets called whenever the command needs to get done. Whenever a key is pressed, a specific command's DoAction() gets triggered. The commands responsible for moving the cursor are a subset of Commands called movementCommands. These specifically control movement of the cursor. By changing the command that gets triggered, the outcome will be different. When the player misses 2 shots on the ducks, their W and S commands get set differently. Normally W makes the cursor move up and S makes the cursor move down. However, when the player misses 2 shots, the command binded to the W key gets set to move down, and the command binded to the S key gets set to move up. There is an array of size 4 that holds all the movementCommands that will be executed. The W key is linked to the movementCommand at index 0. S is linked to index 1. A is linked to index 2. D is linked to index 3. When the player misses 2 shots, the movementCommand at the indexes 0 and 1 are changed, which in turn, changes the action that gets performed when a key is pressed. When the player gest a shot on a duck, then the bindings are reset back to the original state.

QUESTION 7 IMPLEMENTATION
Due to the fact that I made my own project, I did not implement question 7. However, I will explain how I would have implemented question 7. I would choose to implement a game management system. GameManagers are important to helping a game run smoothly. I would create a script called GameManager which would use a singleton design pattern so it is easily accessible from anywhere in the code. I would then attatch this script to an empty game object somewhere in the scene. From there, I would add in code to the GameManager (such as checking how many ducks escaped, ammo, etc). Then whenever this code needs to be accessed, I would use the instance created from the singleton in order to run the code in the GameManager.
